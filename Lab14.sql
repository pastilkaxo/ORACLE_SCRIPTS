alter pluggable database pdb_lvo open;
ALTER SESSION SET "_ORACLE_SCRIPT" = TRUE

--1. Создайте таблицу, имеющую несколько атрибутов, один из которых первичный ключ.

CREATE TABLE LAB_14 (
ID INTEGER PRIMARY KEY,
NAME VARCHAR2(255),
ROLENAME VARCHAR2(100)
CONSTRAINT CHECK_USER_ROLE CHECK(ROLENAME = 'SELLER' OR ROLENAME = 'MANAGER' OR ROLENAME = 'BOSS' OR ROLENAME = 'UNNABLE')
);

-- DROP TABLE LAB_14

--2. Заполните таблицу данными (10 шт.).

INSERT ALL
    INTO LAB_14(ID,NAME,ROLENAME) VALUES(1,'VLAD','BOSS')
    INTO LAB_14(ID,NAME,ROLENAME) VALUES(2,'DIMA','MANAGER')
    INTO LAB_14(ID,NAME,ROLENAME) VALUES(3,'NIKITA','MANAGER')
    INTO LAB_14(ID,NAME,ROLENAME) VALUES(4,'MASHA','MANAGER')
    INTO LAB_14(ID,NAME,ROLENAME) VALUES(5,'ALEX','SELLER')
    INTO LAB_14(ID,NAME,ROLENAME) VALUES(6,'STEEVE','SELLER')
    INTO LAB_14(ID,NAME,ROLENAME) VALUES(7,'LEHA','SELLER')
    INTO LAB_14(ID,NAME,ROLENAME) VALUES(8,'OLEG','SELLER')
    INTO LAB_14(ID,NAME,ROLENAME) VALUES(9,'SVETA','SELLER')
    INTO LAB_14(ID,NAME,ROLENAME) VALUES(10,'SERGEY','SELLER')
SELECT * FROM DUAL;


UPDATE LAB_14 SET ROLENAME = 'SELLER' WHERE ROLENAME = 'MANAGER';
DELETE FROM LAB_14 WHERE ROLENAME = 'MANAGER';
ROLLBACK
SELECT * FROM LAB_14;

--3. Создайте BEFORE – триггер уровня оператора на события INSERT, DELETE и UPDATE.
--Этот и все последующие триггеры должны выдавать сообщение на серверную консоль (DMS_OUTPUT) со своим собственным именем. 

CREATE OR REPLACE TRIGGER CHECK_ACTION_BEFORE
BEFORE INSERT OR UPDATE OR DELETE ON LAB_14
BEGIN
    DBMS_OUTPUT.PUT_LINE('CHECK_ACTION_BEFORE');
END;

--4. Создайте BEFORE-триггер уровня строки на события INSERT, DELETE и UPDATE.

CREATE OR REPLACE TRIGGER CHECK_ACTION_BEFORE_2
BEFORE INSERT OR UPDATE OR DELETE ON LAB_14
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('CHECK_ACTION_BEFORE_2');
END;

--5. Примените предикаты INSERTING, UPDATING и DELETING.

CREATE OR REPLACE TRIGGER PREDICAT_CHECK
BEFORE INSERT OR UPDATE OR DELETE ON LAB_14
BEGIN
    IF INSERTING THEN
        DBMS_OUTPUT.PUT_LINE('ITS INSERTING');
    ELSIF UPDATING THEN
        DBMS_OUTPUT.PUT_LINE('ITS UPDATING');
    ELSIF DELETING THEN
        DBMS_OUTPUT.PUT_LINE('ITS DELETING');
    END IF;
END;

--6. Разработайте AFTER-триггеры уровня оператора на события INSERT, DELETE и UPDATE.

CREATE OR REPLACE TRIGGER CHECK_ACTION_AFTER
AFTER INSERT OR UPDATE OR DELETE ON LAB_14
BEGIN
    DBMS_OUTPUT.PUT_LINE('CHECK_ACTION_AFTER');
    ROLLBACK;
END;

--7. Разработайте AFTER-триггеры уровня строки на события INSERT, DELETE и UPDATE.

CREATE OR REPLACE TRIGGER CHECK_ACTION_AFTER_2
AFTER INSERT OR UPDATE OR DELETE ON LAB_14
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('CHECK_ACTION_AFTER_2');
END;


--8. Создайте таблицу с именем AUDIT. Таблица должна содержать поля: OperationDate, OperationType 
--(операция вставки, обновления и удаления), TriggerName(имя триггера), Data (строка со значениями полей до и после операции).

CREATE TABLE AUDITT (
OperationDate TIMESTAMP,
OperationType VARCHAR2(255),
TriggerName VARCHAR2(255),
Data VARCHAR2(255)
);

-- DROP TABLE AUDITT;

--9. Измените все триггеры таким образом, чтобы они регистрировали все операции с исходной таблицей в таблице AUDIT.

CREATE OR REPLACE TRIGGER INSERT_INTO_LAB
BEFORE INSERT  ON LAB_14
BEGIN
    DBMS_OUTPUT.PUT_LINE('INSERT INTO LAB_14');
END;

CREATE OR REPLACE TRIGGER UPDATE_INTO_LAB
BEFORE  UPDATE  ON LAB_14
BEGIN
    DBMS_OUTPUT.PUT_LINE('UPDATE INTO LAB_14');
END;

CREATE OR REPLACE TRIGGER DELETE_INTO_LAB
BEFORE  DELETE ON LAB_14
BEGIN
    DBMS_OUTPUT.PUT_LINE('DELETE INTO LAB_14');
END;

CREATE OR REPLACE TRIGGER GET_AUDIT
BEFORE INSERT OR UPDATE OR DELETE ON LAB_14
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        INSERT INTO AUDITT(OperationDate, OperationType, TriggerName, Data) VALUES(SYSTIMESTAMP, 'INSERT' , 'INSERT_INTO_LAB', :NEW.ID || ' : ' || :NEW.NAME || ' : ' || :NEW.ROLENAME );
    ELSIF UPDATING THEN
        INSERT INTO AUDITT(OperationDate, OperationType, TriggerName, Data) VALUES(SYSTIMESTAMP, 'UPDATE' , 'UPDATE_INTO_LAB', :OLD.ID || ' - ' || :NEW.ID || ' : ' || :OLD.NAME || ' - ' || :NEW.NAME || ' : ' || :OLD.ROLENAME || ' - ' || :NEW.ROLENAME );
    ELSIF DELETING THEN
        INSERT INTO AUDITT(OperationDate, OperationType, TriggerName, Data) VALUES(SYSTIMESTAMP, 'DELETE' , 'DELETE_INTO_LAB', :OLD.ID || ' : ' || :OLD.NAME || ' : ' || :OLD.ROLENAME );
    END IF;
END;

SELECT * FROM AUDITT;

--10. Выполните операцию, нарушающую целостность таблицы по первичному ключу. Выясните, зарегистрировал ли триггер это событие. Объясните результат.

    INSERT INTO LAB_14(ID,NAME,ROLENAME) VALUES(1,'DIMA','BOSS');
    SELECT * FROM LAB_14;
    
--11. Удалите (drop) исходную таблицу. Объясните результат. Добавьте триггер, запрещающий удаление исходной таблицы.
    DROP TABLE LAB_14;
    
    CREATE OR REPLACE TRIGGER TR_DROP_TABLE
    BEFORE DROP ON SCHEMA
    BEGIN
        IF ORA_DICT_OBJ_NAME = 'LAB_14' THEN
            RAISE_APPLICATION_ERROR(-20001,'DO NOT DROP TABLE: ' || ORA_DICT_OBJ_NAME);
        END IF;
    END;

-- DROP TRIGGER TR_DROP_TABLE;
    
--12. Удалите (drop) таблицу AUDIT. Просмотрите состояние триггеров с помощью SQL-DEVELOPER. Объясните результат. Измените триггеры.

    DROP TABLE AUDITT;
    
    ALTER TABLE AUDITT ENABLE ALL TRIGGERS;

--13. Создайте представление над исходной таблицей. Разработайте INSTEAD OF UPDATE-триггер. Триггер должен добавлять новую строку в таблицу, а старую помечать как недействительную.

    CREATE OR REPLACE VIEW LAB_14_V AS
    SELECT * FROM LAB_14;
    
    SELECT * FROM LAB_14_V;
    
    CREATE OR REPLACE TRIGGER TR_INSTEAD_OF
    INSTEAD OF UPDATE ON  LAB_14_V
    FOR EACH ROW
    BEGIN
            INSERT INTO LAB_14(ID,NAME,ROLENAME) VALUES(:OLD.ID + 10,:OLD.NAME,:OLD.ROLENAME);
            UPDATE LAB_14 SET NAME = 'UNNABLE' , ROLENAME = 'UNNABLE' WHERE ID = :OLD.ID;
            DBMS_OUTPUT.PUT_LINE('TR_INSTEAD_OF');
    END;
    
    UPDATE LAB_14_V SET NAME = 'БГТУ' , ROLENAME = 'MANAGER' WHERE ID = 9;

SELECT * FROM LAB_14_V;

--14. Продемонстрируйте, в каком порядке выполняются триггеры.


CREATE OR REPLACE TRIGGER INSERT_INTO_LAB_BEFORE 
BEFORE INSERT  ON LAB_14
BEGIN
    DBMS_OUTPUT.PUT_LINE('1. INSERT_INTO_LAB_BEFORE');
END;

CREATE OR REPLACE TRIGGER INSERT_INTO_LAB_BEFORE_FRCH
BEFORE INSERT  ON LAB_14
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('2. INSERT_INTO_LAB_BEFORE_FRCH');
END;

CREATE OR REPLACE TRIGGER INSERT_INTO_LAB_AFTER
AFTER INSERT  ON LAB_14
BEGIN
    DBMS_OUTPUT.PUT_LINE('3. INSERT_INTO_LAB_AFTER');
END;

CREATE OR REPLACE TRIGGER INSERT_INTO_LAB_AFTER_FRCH
AFTER INSERT  ON LAB_14
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('4. INSERT_INTO_LAB_AFTER_FRCH');
END;

CREATE OR REPLACE TRIGGER OPERATOR
BEFORE INSERT ON LAB_14
FOR EACH ROW
FOLLOWS INSERT_INTO_LAB_BEFORE_FRCH
BEGIN
    IF INSERTING THEN
        DBMS_OUTPUT.PUT_LINE('5. OPERATOR');
    END IF;
END;



--15. Создайте несколько триггеров одного типа, реагирующих на одно и то же событие, и покажите, в каком порядке они выполняются. Измените порядок выполнения этих триггеров.


CREATE OR REPLACE TRIGGER INSERT_INTO_LAB_BEFORE_2 
BEFORE INSERT  ON LAB_14
BEGIN
    DBMS_OUTPUT.PUT_LINE('2. INSERT_INTO_LAB_BEFORE_2');
END;

CREATE OR REPLACE TRIGGER INSERT_INTO_LAB_BEFORE_3 
BEFORE INSERT  ON LAB_14
FOLLOWS INSERT_INTO_LAB_BEFORE_1
BEGIN
    DBMS_OUTPUT.PUT_LINE('3. INSERT_INTO_LAB_BEFORE_3');
END;

CREATE OR REPLACE TRIGGER INSERT_INTO_LAB_BEFORE_1 
BEFORE INSERT  ON LAB_14

BEGIN
    DBMS_OUTPUT.PUT_LINE('1. INSERT_INTO_LAB_BEFORE_1');
END;

    INSERT INTO LAB_14(ID,NAME,ROLENAME) VALUES(3,'DIMA','BOSS');